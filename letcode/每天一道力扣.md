#### [14. 最长公共前缀](https://leetcode.cn/problems/longest-common-prefix/)

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

**示例 1：**

```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**示例 2：**

```
输入：strs = ["dog","racecar","car"]
输出：""
解释：输入不存在公共前缀。
```

**提示：**

- `1 <= strs.length <= 200`
- `0 <= strs[i].length <= 200`
- `strs[i]` 仅由小写英文字母组成

```javascript
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function(strs) {

    let base = strs[0];
    let len = strs[0].length;
    let str = ''
    // 先取第一个的长度
    for(let i = 0; i < len; i++) {
        let isEual = true
        // 从第二个开始和第一个对比
        for(let j =1; j < strs.length; j++) {
            if (strs[j][i] !== base[i]) {
                isEual = false
            }
        }
        if (isEual) {
            str += base[i]
        } else {
            return str
        }
    }
    return str;

};
```



#### [1. 两数之和](https://leetcode.cn/problems/two-sum/)

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

 

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**

```
输入：nums = [3,3], target = 6
输出：[0,1]
```

 

**提示：**

- `2 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`
- **只会存在一个有效答案**

**进阶：**你可以想出一个时间复杂度小于 `O(n2)` 的算法吗？



```javascript
/** 暴力解法
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 * o(n2)
 */
var twoSum = function(nums, target) {
    for(let i = 0; i < nums.length; i++) {
        for(let j = i + 1; j < nums.length; j++) {
            if (nums[i] + nums[j] === target) {
                return [i, j]
            }
        }
    }

};
/** [0, 2, 8, 4, 5] 13
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    const obj = {}
    for(let i = 0; i < nums.length; i++) {
        let key =  target - nums[i]; // 9 - 2 = 7;
        // 已经存在要查找的值
        if (obj[nums[i]]) { // 
            return [obj[nums[i]], i]
        } else {
            // 要查找的值的key和当前值的索引
            obj[key] = i + '' // 防止为0这样
        }
    }

};

```



